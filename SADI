#!/usr/bin/perl -w

package BIO2RDF_WRAPPER;
use strict;
use warnings;
use SADI::Simple 0.007;
use XML::SAX;
use Log::Log4perl qw(:easy);
use base 'SADI::Simple::SyncService';  # 'SADI::Simple::SyncService' or 'SADI::Simple::AsyncService'

Log::Log4perl->easy_init($WARN);
my $debug = 0;  # switching this to "1" allows you to run the SADI script from the command line with useful default values

# if your server does not provide these environment variables
# REQUEST_URI=/cgi-bin/SADI/someendpoint/some_service_name
# HTTP_HOST=biordf.org:8080
# you will need to set the value of $THISSCRIPT manually for each service!
my $request_uri = $ENV{'REQUEST_URI'};
my $http_host = $ENV{'HTTP_HOST'};
my $THISSCRIPT;

if (defined($request_uri) && defined($http_host)){
	$THISSCRIPT = "http://" . $http_host . $request_uri;
} else {

	$THISSCRIPT = "http://example.org/YOUR/SERVICE_HERE";
}
&easy_die("somehow script name could not be determined\n") unless $THISSCRIPT;

my $pathinfo = $ENV{'PATH_INFO'};
$debug && ($pathinfo = "sgd/Protein_sameAs_Protein");
&easy_die("path information from URL did not match pattern SADI/source/servicename\n") unless $pathinfo =~ /\/?(\S+)\/(\S+)\/?/;


my ($dataset, $method) = ($1, $2);
&easy_die("path information could not be parsed into 'source' and 'servicename'\n") unless ($dataset && $method);
my $CFG = &getConfig($dataset, $method);


open (SPARQL, "/home/biordf/public_html/ontologies/$dataset/$method.sparql");
my $sparql = "";
while (<SPARQL>){
	$sparql .= $_;
}
close SPARQL;

open (OWL, "/home/biordf/public_html/ontologies/$dataset/$method.owl");
my $owl = "";
while (<OWL>){
	$owl .= $_;
}
close OWL;
$debug && print "$sparql \n\n $owl\n\n";
&easy_die("couldn't find sparql or owl files where expected\n") unless ($sparql && $owl);

my $servicename = $CFG->{'INPUTCLASS_NAME'}."_".$CFG->{'PREDICATE_NAME'};
$debug && print "servicename: $servicename\n\n";
&easy_die("couldn't create the servicename\n") unless $servicename;

my $description = "consumes $CFG->{'INPUTCLASS_NAME'} identifiers ($CFG->{'INPUTCLASS_URI'} namespace) and generates the \'$CFG->{'PREDICATE_NAME'}\' property for them from the Bio2RDF $dataset endpoint";
$debug && print "$description\n\n";
&easy_die("couldn't create service description\n") unless $description;

my %config = (
    ServiceName => $servicename,
    Description => $description,
    InputClass => $CFG->{'INPUTCLASS_URI'},
    OutputClass => $CFG->{'OUTPUTCLASS_URI'},
    URL => $THISSCRIPT, 
    Authority => 'wilkinsonlab.info', 
    Provider => 'markw@illuminae.com',
    ServiceType => 'http://edamontology.org/operation_2421',  # EDAM:Database Query
    Authoritative => 0,
);

$debug && &process_it();  # in debug/command line mode the sub is explicitly called


my $service = BIO2RDF_WRAPPER->new(%config);
$service->handle_cgi_request;

#-----------------------------------------------------------------
# SERVICE IMPLEMENTATION PART
#-----------------------------------------------------------------

use RDF::Trine::Node::Resource;
use RDF::Trine::Node::Literal;
use RDF::Trine::Statement;
use RDF::Query::Client;

=head2 process_it

 Function: implements the business logic of a SADI service
 Args    : $inputs - ref to an array of RDF::Trine::Node::Resource
           $input_model - an RDF::Trine::Model containing the input RDF data
           $output_model - an RDF::Trine::Model containing the output RDF data
 Returns : nothing (service output is stored in $output_model)

=cut

sub process_it {

    my ($self, $inputs, $input_model, $output_model) = @_;
                  					$debug && ( $output_model = RDF::Trine::Model->new());              #############################
                					$debug && ( $inputs = ["http://bio2rdf.org/sgd:Hsh155p"]);  ###################################
    foreach my $input (@$inputs) {
									$debug && ( $input = RDF::Trine::Node::Resource->new($input));  ####################################
    	my $inputURIString = $input->as_string;
		$sparql =~ s/\%VAR/$inputURIString/;
		my $query = RDF::Query::Client->new($sparql);
		my $iterator = $query->execute($CFG->{'GENERIC_ENDPOINT'});  

		
		if ($iterator){ 
			while (my $row = $iterator->next) {
	   				# $row is a HASHref containing variable name -> RDF Term bindings
	   				$debug && print $row->{ 'obj' }->as_string, "\n\n";
	   				my $resultURI = $row->{ 'obj' }->as_string;
	   				$resultURI =~ s/[\<\>]//g;
	   				my $object = RDF::Trine::Node::Resource->new($resultURI);
	   				my $pred = RDF::Trine::Node::Resource->new($CFG->{'PREDICATE_URI'});
   	   			    my $statement = RDF::Trine::Statement->new($input, $pred, $object);  ##### CHECK v.v. SUBJECT vs. INPUT
	        		$output_model->add_statement($statement);
			}
   		}
#   		&add_provenance_metadata($output_model);
    }
    $debug && print $output_model->as_string();

}

sub add_provenance_metadata {
	my ($output_model) = @_;
	
	use constant RDFS => "http://www.w3.org/2000/01/rdf-schema#";
	use constant RDFTYPE => "http://www.w3.org/2000/01/rdf-schema#";
	
	use constant SIO_RESULTOF => "http://semanticscience.org/resource/is-result-of";
	# need to create a uniqe bnode here
	use constant SIO_SERVINVOC => "http://semanticscience.org/resource/SADI-web-service-invocation"; 
	my $output_class = $CFG->{'OUTPUTCLASS_URI'};
	my $statement1 = &statement($output_class, SIO_RESULTOF, "BNODE_HERE" );
	my $statement2 = &statement("????" );
	
	
#if I equivalentClass r some A
# and O equivalentClass I and s some B
#
#Not a clue what you mean by that...
#
#
#B equivalentClass sio:is-result-of :unique-service-invocation
#
#B is?
#
#
#I and O are SADI service inputs and outputs, B is the output of the service which is related to the input by s.
#
#:unique-service-invocation
# a sio:SADI-web-service-invocation;
# dc:date value "datetime-here"^^xsd:datetime; 
# sio:has-agent :my-sadi-service
#:my-sadi-service
# a sio:SADI-Web-Service; 
# dc:creator :creator
# dc:publisher :publisher
	
}

sub statement {
	my ($s, $p, $o) = @_;
	my $subject = RDF::Trine::Node::Resource->new($s);
	my $pred = RDF::Trine::Node::Resource->new($p);
	my $obj = RDF::Trine::Node::Resource->new($o);
	my $statement = RDF::Trine::Statement->new($subject, $pred, $obj);
	return $statement;
}

sub easy_die {
	my $message = shift; 
	print "Content-type: text/plain", "\n\n";
	print "$message\n";
# uncomment this if you want to see a dump of your server environment variables
# by executing cgi-bin/SADI with no additional path information in your browser
#	for (keys %ENV) { 
#		print "$_=$ENV{$_}\n"; 
#	}
	
	exit 0;
}

sub getConfig{
	my ($dataset, $method) = @_;
	open (CFG, "/home/biordf/public_html/ontologies/$dataset/$method.cfg");
	my %config;
	foreach (
	"INPUTCLASS_URI", 
	"INPUTCLASS_NAME", 
	"OUTPUTCLASS_NAME", 
	"OUTPUTCLASS_URI", 
	"PREDICATE_NAME", 
	"PREDICATE_URI",
	"ORIGINAL_ENDPOINT", 
	"GENERIC_ENDPOINT") {
		
		my $line = <CFG> || easydie("not enough parameters in the config file; missing $_\n");
		easydie("config line $line doesn't match expected structure\n") unless $line =~ /$_\=(\S+)/;
		my $value = $1;
		if ($_ eq "INPUTCLASS_NAME" || $_ eq "OUTPUTCLASS_NAME" || $_ eq "PREDICATE_NAME"){
			$value =~ /[:#]?([^:#]+)$/;  # sometimes includes the Bio2RDF namespace prefix, so remove that
			$value = $1;
		}
		 $config{$_} = $value;
	}
	close CFG;
	return \%config;	
}

1;
